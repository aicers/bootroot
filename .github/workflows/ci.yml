name: CI

permissions:
  contents: read

on:
  push:
    branches:
      - "**"
  pull_request:
    branches:
      - main

env:
  CARGO_TERM_COLOR: always

jobs:
  changes:
    name: Change Filter
    runs-on: ubuntu-latest
    outputs:
      docs_only: ${{ steps.decide.outputs.docs_only }}
    steps:
      - uses: actions/checkout@v6

      - name: Filter Paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            docs:
              - "docs/**"
              - "**/*.md"
              - "mkdocs.yml"
              - ".markdownlint*"
            code:
              - "src/**"
              - "tests/**"
              - "scripts/**"
              - "Cargo.toml"
              - "Cargo.lock"
              - "pyproject.toml"
              - "docker-compose.yml"
              - "Dockerfile*"
              - "responder.toml.example"
              - ".github/workflows/**"

      - name: Decide Docs-Only
        id: decide
        run: |
          if [ "${{ steps.filter.outputs.docs }}" = "true" ] && [ "${{ steps.filter.outputs.code }}" != "true" ]; then
            echo "docs_only=true" >> "$GITHUB_OUTPUT"
          else
            echo "docs_only=false" >> "$GITHUB_OUTPUT"
          fi

  check:
    name: Quality Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust Toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.x"

      - name: Install Python Tools
        run: python -m pip install --upgrade pip ruff mkdocs-material mkdocs-static-i18n

      - name: Check Rust Formatting
        run: cargo fmt -- --check --config group_imports=StdExternalCrate

      - name: Check Rust Lints (Clippy)
        run: cargo clippy --all-targets -- -D warnings

      - name: Check Python Formatting
        run: ruff format --check .

      - name: Check Python Lints
        run: ruff check .

      - name: Setup Biome
        uses: biomejs/setup-biome@v2
        with:
          version: latest

      - name: Run Biome (Config/JSON Check)
        run: biome ci --error-on-warnings .

      - name: Run Markdown Lint
        uses: DavidAnson/markdownlint-cli2-action@v22
        with:
          globs: "**/*.md"

      - name: Build Docs
        run: mkdocs build --strict

      - name: Install cargo-audit
        run: cargo install cargo-audit || true

      - name: Run Security Audit
        run: cargo audit

  test-core:
    name: Unit & CLI Smoke
    needs: [check, changes]
    if: needs.changes.outputs.docs_only != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust Toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2

      # --- Unit Testing ---
      - name: Run Unit Tests
        run: cargo test

      # --- E2E Integration Testing (Docker) ---
      - name: Set secrets directory
        run: echo "BOOTROOT_SECRETS_DIR=$GITHUB_WORKSPACE/secrets" >> "$GITHUB_ENV"

      - name: Initialize Test CA
        run: |
          mkdir -p "$BOOTROOT_SECRETS_DIR"
          echo "password" > "$BOOTROOT_SECRETS_DIR/password.txt"
          # Initialize step-ca configuration
          docker run --user root --rm -v "$BOOTROOT_SECRETS_DIR:/home/step" smallstep/step-ca \
            step ca init \
            --name "Bootroot CI CA" \
            --provisioner "admin" \
            --dns "localhost,bootroot-ca" \
            --address ":9000" \
            --password-file /home/step/password.txt \
            --provisioner-password-file /home/step/password.txt \
            --acme

      - name: Fix Permissions (for Docker mount)
        run: |
          mkdir -p "$BOOTROOT_SECRETS_DIR" certs
          sudo chown -R "$USER":"$USER" "$BOOTROOT_SECRETS_DIR"
          sudo chmod -R 700 "$BOOTROOT_SECRETS_DIR"
          sudo chmod -R 755 certs

      - name: Monitoring Integration Test (E2E)
        run: cargo test --test monitoring_integration

      - name: Start Services (Docker Compose)
        run: docker compose -f docker-compose.yml -f docker-compose.test.yml up --build -d

      - name: Wait for services
        run: sleep 10

      - name: CLI Infra Up (Smoke)
        run: |
          docker compose -f docker-compose.yml -f docker-compose.test.yml build step-ca bootroot-http01
          cargo run --bin bootroot -- infra up

      - name: CLI Init (Smoke)
        run: |
          BOOTROOT_LANG=en printf "y\ny\ny\nn\n" | cargo run --bin bootroot -- init \
            --auto-generate \
            --show-secrets \
            --http-hmac "dev-hmac" \
            --db-dsn "postgresql://step:step@127.0.0.1:5432/step" \
            --secrets-dir "$BOOTROOT_SECRETS_DIR" \
            --responder-url "http://localhost:8080" \
            --skip-responder-check | tee cli-init.log

          ROOT_TOKEN="$(awk -F': ' '/root token:/ {print $2; exit}' cli-init.log)"
          if [ -z "${ROOT_TOKEN:-}" ]; then
            echo "Failed to read root token from init output"
            exit 1
          fi
          echo "OPENBAO_ROOT_TOKEN=${ROOT_TOKEN}" >> "$GITHUB_ENV"

      - name: CLI Service Add + Verify (Smoke)
        run: |
          mkdir -p tmp certs
          cat > tmp/agent.toml <<'EOF'
          email = "admin@example.com"
          server = "https://localhost:9000/acme/acme/directory"
          domain = "trusted.domain"

          [acme]
          directory_fetch_attempts = 10
          directory_fetch_base_delay_secs = 1
          directory_fetch_max_delay_secs = 10
          poll_attempts = 15
          poll_interval_secs = 2
          http_responder_url = "http://localhost:8080"
          http_responder_hmac = "dev-hmac"
          http_responder_timeout_secs = 5
          http_responder_token_ttl_secs = 300
          EOF

          cargo run --bin bootroot -- service add \
            --service-name edge-proxy \
            --deploy-type daemon \
            --hostname edge-node-01 \
            --domain trusted.domain \
            --agent-config "$(pwd)/tmp/agent.toml" \
            --cert-path "$(pwd)/certs/edge-proxy.crt" \
            --key-path "$(pwd)/certs/edge-proxy.key" \
            --instance-id 001 \
            --root-token "$OPENBAO_ROOT_TOKEN"

          cargo run --bin bootroot -- service add \
            --service-name web-app \
            --deploy-type docker \
            --hostname web-01 \
            --domain trusted.domain \
            --agent-config "$(pwd)/tmp/agent.toml" \
            --cert-path "$(pwd)/certs/web-app.crt" \
            --key-path "$(pwd)/certs/web-app.key" \
            --instance-id 001 \
            --container-name web-app \
            --root-token "$OPENBAO_ROOT_TOKEN"

          RESPONDER_IP="$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' bootroot-http01)"
          if [ -z "${RESPONDER_IP:-}" ]; then
            echo "Failed to read responder container IP"
            exit 1
          fi
          docker exec bootroot-ca sh -c "printf '%s %s\n' '$RESPONDER_IP' '001.edge-proxy.edge-node-01.trusted.domain' >> /etc/hosts"
          docker exec bootroot-ca sh -c "printf '%s %s\n' '$RESPONDER_IP' '001.web-app.web-01.trusted.domain' >> /etc/hosts"

          host="001.edge-proxy.edge-node-01.trusted.domain"
          for attempt in {1..15}; do
            if docker exec bootroot-ca bash -lc "timeout 2 bash -lc 'echo > /dev/tcp/${host}/80'" >/dev/null 2>&1; then
              echo "Responder HTTP-01 is reachable from step-ca"
              break
            fi
            echo "Waiting for responder HTTP-01 (attempt ${attempt}/15)"
            sleep 1
          done
          if ! docker exec bootroot-ca bash -lc "timeout 2 bash -lc 'echo > /dev/tcp/${host}/80'" >/dev/null 2>&1; then
            echo "Responder HTTP-01 is not reachable from step-ca"
            docker logs bootroot-http01
            exit 1
          fi

          cargo build --bin bootroot-agent
          export PATH="$(pwd)/target/debug:$PATH"

          cargo run --bin bootroot -- verify \
            --service-name edge-proxy \
            --agent-config "$(pwd)/tmp/agent.toml"

          cargo run --bin bootroot -- verify \
            --service-name web-app \
            --agent-config "$(pwd)/tmp/agent.toml"

      - name: Verify CA Health
        run: |
          for i in {1..10}; do
            if curl -k --fail https://localhost:9000/health; then
              exit 0
            fi
            echo "Waiting for CA health..."
            sleep 3
          done
          docker logs bootroot-ca
          exit 1

      - name: Verify Agent Success (E2E)
        run: |
          for i in {1..6}; do
            if docker logs bootroot-agent 2>&1 | grep -q "Successfully issued certificate"; then
              echo "PASS: Certificate issued successfully"
              exit 0
            fi
            if docker logs bootroot-agent 2>&1 | grep -q "Certificate issuance succeeded"; then
              echo "PASS: Certificate issued successfully"
              exit 0
            fi
            if [ -s certs/bootroot-agent.crt ] && [ -s certs/bootroot-agent.key ]; then
              echo "PASS: Certificate files created"
              exit 0
            fi
            echo "Waiting for certificate issuance..."
            sleep 5
          done

          echo "FAIL: Certificate issue message not found"
          echo "=== Agent Logs ==="
          docker logs bootroot-agent
          exit 1

      - name: Cleanup
        if: always()
        run: docker compose -f docker-compose.yml -f docker-compose.test.yml down

  test-docker-e2e-matrix:
    name: Docker E2E (${{ matrix.scenario.label }})
    needs: [check, changes]
    if: needs.changes.outputs.docs_only != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        scenario:
          - label: local-default
            script: run-local-lifecycle.sh
            resolution: fqdn-only-hosts
            artifact: ci-local-default
          - label: local-hosts
            script: run-local-lifecycle.sh
            resolution: hosts-all
            artifact: ci-local-hosts
          - label: remote-default
            script: run-remote-lifecycle.sh
            resolution: fqdn-only-hosts
            artifact: ci-remote-default
          - label: remote-hosts
            script: run-remote-lifecycle.sh
            resolution: hosts-all
            artifact: ci-remote-hosts
          - label: rotation
            script: run-rotation-recovery.sh
            resolution: ""
            artifact: ci-rotation
    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust Toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2

      - name: Build bootroot binaries
        run: cargo build --bin bootroot --bin bootroot-remote --bin bootroot-agent

      - name: Run E2E scenario (lifecycle)
        if: matrix.scenario.label != 'rotation'
        run: |
          ARTIFACT_DIR="$(pwd)/tmp/e2e/${{ matrix.scenario.artifact }}-${GITHUB_RUN_ID}"
          ARTIFACT_DIR="$ARTIFACT_DIR" \
          PROJECT_NAME="bootroot-e2e-ci-${{ matrix.scenario.label }}-${GITHUB_RUN_ID}" \
          RESOLUTION_MODE="${{ matrix.scenario.resolution }}" \
          SECRETS_DIR="$(pwd)/secrets" \
          TIMEOUT_SECS=120 \
          INFRA_UP_ATTEMPTS=12 \
          INFRA_UP_DELAY_SECS=10 \
          VERIFY_ATTEMPTS=5 \
          VERIFY_DELAY_SECS=5 \
          BOOTROOT_BIN="$(pwd)/target/debug/bootroot" \
          BOOTROOT_REMOTE_BIN="$(pwd)/target/debug/bootroot-remote" \
          BOOTROOT_AGENT_BIN="$(pwd)/target/debug/bootroot-agent" \
          ./scripts/impl/${{ matrix.scenario.script }} || {
            echo "${{ matrix.scenario.label }} failed"
            [ -f "$ARTIFACT_DIR/phases.log" ] && cat "$ARTIFACT_DIR/phases.log" || true
            [ -f "$ARTIFACT_DIR/run.log" ] && tail -n 200 "$ARTIFACT_DIR/run.log" || true
            [ -f "$ARTIFACT_DIR/init.raw.log" ] && tail -n 200 "$ARTIFACT_DIR/init.raw.log" || true
            [ -f "$ARTIFACT_DIR/init.log" ] && tail -n 200 "$ARTIFACT_DIR/init.log" || true
            [ -f "$ARTIFACT_DIR/compose-logs.log" ] && tail -n 200 "$ARTIFACT_DIR/compose-logs.log" || true
            exit 1
          }

      - name: Run E2E scenario (rotation)
        if: matrix.scenario.label == 'rotation'
        run: |
          SCENARIO_FILE="$(pwd)/tests/e2e/docker_harness/scenarios/scenario-c-multi-node-uneven.json" \
          ARTIFACT_DIR="$(pwd)/tmp/e2e/${{ matrix.scenario.artifact }}-${GITHUB_RUN_ID}" \
          PROJECT_NAME="bootroot-e2e-ci-rotation-${GITHUB_RUN_ID}" \
          ROTATION_ITEMS="secret_id,eab,responder_hmac,trust_sync" \
          TIMEOUT_SECS=90 \
          BOOTROOT_BIN="$(pwd)/target/debug/bootroot" \
          BOOTROOT_REMOTE_BIN="$(pwd)/target/debug/bootroot-remote" \
          ./scripts/impl/run-rotation-recovery.sh

      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.scenario.artifact }}-${{ github.run_id }}
          path: tmp/e2e/${{ matrix.scenario.artifact }}-${{ github.run_id }}
          if-no-files-found: warn
