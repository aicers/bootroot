# Concepts

This section gives you enough background to understand what you are operating.

## PKI and Certificates

- A **Certificate Authority (CA)** signs certificates that bind a public key
  to an identity (a hostname or IP address).
- A **certificate** contains identity fields (Subject, SANs), validity, and
  the CA signature.
- A **private key** must be protected. It proves possession of the identity.

### step-ca standard CA layout

step-ca uses a **root CA + intermediate CA** layout by default. The
intermediate issues end-entity certificates, while the root signs the
intermediate.

bootroot keeps this structure, and the following files are created:

- `root_ca.crt`: root CA certificate
- `intermediate_ca.crt`: intermediate CA certificate

## SAN (Subject Alternative Name)

SANs are the identities inside the certificate. Common types:

- **DNS**: `example.internal`
- **IP**: `192.0.2.10`

In the bootroot CLI ecosystem, DNS SANs use this format (same for daemon and docker):

`<instance_id>.<service_name>.<hostname>.<domain>`

## mTLS

Mutual TLS requires both client and server to present certificates.
If you control issuance and renewal, you can automate mTLS safely.

In bootroot, the default trust model is **"accept only certificates issued by
the same step-ca"**. In practice, both peers must validate back to the **same
CA chain** for the connection to be allowed. The artifact used for that
validation is the **CA bundle**.

### CA bundle

A CA bundle is a file containing the **root and intermediate certificates**
that you trust. Services use it as the trust store (the set of trusted CAs)
for verifying peer certificates.

- bootroot-agent splits the chain from the ACME response and writes it to
  `ca_bundle_path`.
- mTLS services load that bundle to **accept only certificates issued by the
  same step-ca**.

The ACME certificate response is typically a **concatenated PEM** string.
The first PEM block is the **leaf certificate**, followed by the **chain**
(intermediate/root). bootroot-agent parses the PEM blocks in order, keeps the
first block as the leaf, and writes the remaining blocks to `ca_bundle_path`.

## CSR (Certificate Signing Request)

A **CSR** is generated by the client. It contains the public key and requested
identities (SANs). The CA verifies the request and issues a certificate.

## ACME

ACME (RFC 8555) is the automated issuance protocol used by step-ca. An ACME
account is a registration at the CA that includes an account key and contact
email. bootroot-agent creates and registers this account automatically on its
first connection.

Key terms in the ACME flow:

- **Account**: a registered identity at the CA, tied to an account key and
  contact info. All orders are signed by this account.
- **Order**: a request to issue a certificate for a set of identifiers (SANs).
- **Authorization**: proof of control for a specific identifier.
- **Challenge**: the validation method for an authorization (HTTP-01 here).
- **Finalize**: submits the CSR once all authorizations are valid.
- **Certificate**: the issued certificate downloaded from the CA.

## HTTP-01 Challenge

HTTP-01 is a domain control check. Its purpose is to ensure certificates
are issued only to the **actual domain owner**. The CA gives the client a
**token**, and
then makes an HTTP request to verify that the domain owner can serve it.

Flow:

1. step-ca returns an HTTP-01 token to bootroot-agent as part of the
   authorization response.
2. bootroot-agent receives that token and registers it with the **HTTP-01
   responder** admin API (port 8080).
3. step-ca sends an HTTP request to the **HTTP-01 responder** at
   `http://<domain>/.well-known/acme-challenge/<token>` on port 80.
4. The **HTTP-01 responder** returns the correct key authorization, and the
   CA marks the **domain control authorization** as valid.

## EAB (External Account Binding)

EAB lets a CA restrict **account registrations** from clients such as
bootroot-agent. The **client** must submit the `kid`/`hmac` issued by the
CA **during account registration**, or the CA will reject the request.
bootroot-agent can load EAB from config or CLI.

- `kid` (key ID): an identifier for the EAB key pair issued by the CA.
- `hmac`: the shared HMAC key used to bind the external account.
- HMAC: a keyed hash (Hash-based Message Authentication Code) that proves
  both parties share the same secret.

## Secret Manager (OpenBao)

In production, avoid hardcoding secrets in files or environment variables.
To reduce security risk, use a secret manager like OpenBao, which provides
Vault-compatible KV v2
storage (Vault is a widely used secrets manager; KV v2 is its versioned
key/value secrets engine). For bootroot, store and inject:

- step-ca password (`password.txt`)
- step-ca DB DSN (Data Source Name: a connection string with host/user/password)
- HTTP-01 responder HMAC
- EAB `kid`/`hmac`

### Secret injection flow (OpenBao Agent)

Runtime services do not talk to OpenBao directly. The **OpenBao Agent**
logs in with AppRole and renders secrets to files:

- OpenBao Agent logs in with AppRole (role_id + secret_id).
- Renders templates to files (e.g., `password.txt`, `responder.toml`,
  `agent.toml`).
- `bootroot-agent`, the HTTP-01 responder, and step-ca read the rendered
  files.

The `bootroot` CLI calls the OpenBao API only for **administrative actions**
like init/rotate.

#### OpenBao bootstrap and access

OpenBao is initialized with **unseal keys** and a **root token**. Unseal keys
unlock the storage on startup, while the root token grants full administrative
access.

#### Unseal keys custody

Unseal keys are split using **shares (total)** and **threshold (required)**,
and you must provide at least the threshold count to unseal. OpenBao
generates the unseal keys and root token during initialization; an operator
must capture and store them securely. They are needed later to unseal
OpenBao after restarts and to perform administrative recovery or policy
changes.

#### AppRole credentials

After bootstrap, the OpenBao Agent authenticates using **AppRole**
(role_id + secret_id) and receives short-lived tokens. Policies should grant
only the minimum paths required (read-only for runtime services). AppRole
`role_id` and `secret_id` are issued by OpenBao. `role_id` identifies the
role and is stable, while `secret_id` is a credential that can be rotated.
Operators deliver the initial values to services (or OpenBao Agent), and
rotate `secret_id` as needed.

### Dev-only auto-unseal (unsafe)

In dev/test environments, you can pass `--openbao-unseal-from-file <path>` to
`bootroot infra up` or `bootroot init` to **auto-unseal from a local file**.
This is **unsafe for production**. Storing unseal keys on disk increases the
blast radius if the host is compromised.
