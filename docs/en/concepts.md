# Concepts

This section gives you enough background to understand what you are operating.

## PKI and Certificates

- A **Certificate Authority (CA)** signs certificates that bind a public key
  to an identity (a hostname or IP address).
- A **certificate** contains identity fields (Subject, SANs), validity, and
  the CA signature.
- A **private key** must be protected. It proves possession of the identity.

## SAN (Subject Alternative Name)

SANs are the identities inside the certificate. Common types:

- **DNS**: `example.internal`
- **IP**: `192.0.2.10`

## mTLS

Mutual TLS requires both client and server to present certificates.
If you control issuance and renewal, you can automate mTLS safely.

## CSR (Certificate Signing Request)

A **CSR** is generated by the client. It contains the public key and requested
identities (SANs). The CA verifies the request and issues a certificate.

## ACME

ACME (RFC 8555) is the automated issuance protocol used by step-ca. An ACME
account is a registration at the CA that includes an account key and contact
email. bootroot-agent creates and registers this account automatically on its
first connection.

Key terms in the ACME flow:

- **Account**: a registered identity at the CA, tied to an account key and
  contact info. All orders are signed by this account.
- **Order**: a request to issue a certificate for a set of identifiers (SANs).
- **Authorization**: proof of control for a specific identifier.
- **Challenge**: the validation method for an authorization (HTTP-01 here).
- **Finalize**: submits the CSR once all authorizations are valid.
- **Certificate**: the issued certificate downloaded from the CA.

## HTTP-01 Challenge

HTTP-01 is a domain control check. The CA gives the client a **token**, and
then makes an HTTP request to verify that the domain owner can serve it.

Flow:

1. step-ca returns an HTTP-01 token to bootroot-agent as part of the
   authorization response.
2. bootroot-agent receives that token and registers it with the **HTTP-01
   responder** admin API (port 8080).
3. step-ca sends an HTTP request to the **HTTP-01 responder** at
   `http://<domain>/.well-known/acme-challenge/<token>` on port 80.
4. The **HTTP-01 responder** returns the correct key authorization, and the
   CA marks the **domain control authorization** as valid.

## EAB (External Account Binding)

EAB allows a CA to restrict registrations. The operator supplies a key ID
and HMAC key. bootroot-agent can load EAB from config or CLI.

- `kid` (key ID): an identifier for the EAB key pair issued by the CA.
- `hmac`: the shared HMAC key used to bind the external account.
- HMAC: a keyed hash (Hash-based Message Authentication Code) that proves
  both parties share the same secret.

## Secret Manager (OpenBao)

In production, avoid hardcoding secrets in files or environment variables.
Use a secret manager like OpenBao, which provides Vault-compatible KV v2
storage (Vault is a widely used secrets manager; KV v2 is its versioned
key/value secrets engine). For bootroot, store and inject:

- step-ca password (`password.txt`)
- step-ca DB DSN (Data Source Name: a connection string with host/user/password)
- HTTP-01 responder HMAC
- EAB `kid`/`hmac`

### Secret injection flow (OpenBao Agent)

Runtime services do not talk to OpenBao directly. The **OpenBao Agent**
logs in with AppRole and renders secrets to files:

- OpenBao Agent logs in with AppRole (role_id + secret_id).
- Renders templates to files (e.g., `password.txt`, `responder.toml`,
  `agent.toml`).
- `bootroot-agent`, the HTTP-01 responder, and step-ca read the rendered
  files.

The `bootroot` CLI calls the OpenBao API only for **administrative actions**
like init/rotate.

OpenBao is initialized with **unseal keys** and a **root token**. Unseal keys
unlock the storage on startup, while the root token grants full administrative
access. After bootstrap, the OpenBao Agent authenticates using **AppRole**
(role_id + secret_id) and receives short-lived tokens. Policies should grant
only the minimum paths required (read-only for runtime services).
Unseal keys are split using **shares (total)** and **threshold (required)**,
and you must provide at least the threshold count to unseal.
OpenBao generates the unseal keys and root token during initialization; an
operator must capture and store them securely.
They are needed later to unseal OpenBao after restarts and to perform
administrative recovery or policy changes.
AppRole `role_id` and `secret_id` are issued by OpenBao. `role_id` identifies
the role and is stable, while `secret_id` is a credential that can be rotated.
Operators deliver the initial values to services (or OpenBao Agent), and
rotate `secret_id` as needed.

### Dev-only auto-unseal (unsafe)

In dev/test environments, you can pass `--openbao-unseal-from-file <path>` to
`bootroot infra up` or `bootroot init` to **auto-unseal from a local file**.
This is **unsafe for production**. Storing unseal keys on disk increases the
blast radius if the host is compromised.
